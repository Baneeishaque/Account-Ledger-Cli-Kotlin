/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package transactionInserterForAccountLedger.cli.app

import kotlinx.cli.ArgParser
import kotlinx.cli.ArgType
import kotlinx.cli.default
import kotlinx.coroutines.runBlocking
import transactionInserterForAccountLedger.api.response.AccountResponse
import transactionInserterForAccountLedger.api.response.AccountsResponse
import transactionInserterForAccountLedger.api.response.LoginResponse
import transactionInserterForAccountLedger.retrofit.ResponseHolder
import transactionInserterForAccountLedger.retrofit.data.AccountsDataSource
import transactionInserterForAccountLedger.retrofit.data.UserDataSource
import transactionInserterForAccountLedger.to_utils.PrintUtils
import transactionInserterForAccountLedger.to_utils.ToDoUtils
import java.util.*

object AppProperties {

    const val appName = "Account Ledger CLI App"
    const val version = "0.0.1"
}

val reader = Scanner(System.`in`)

fun main(args: Array<String>) {

    val parser = ArgParser(programName = "${AppProperties.appName}:: ${AppProperties.version}")
    val version by parser.option(type = ArgType.Boolean, shortName = "V", description = "Version").default(false)

    if (args.isEmpty()) {

//        println("No options...")
//        TODO : Implement common back & exit for menus
        do {
            println("\nAccount Ledger")
            println("1 : Login")
            println("2 : Registration")
            println("0 : Exit")
            println()
            print("Enter Your Choice : ")
            val choice = reader.nextInt()
            when (choice) {

                1 -> login()
                2 -> register()
                0 -> {
                    println("Thanks...")
                    return
                }
                else -> println("Invalid option, try again...")
            }
        } while (choice != 0)

    } else {

        // Add all input to parser
        parser.parse(args)

        if (version) println(AppProperties.version)
    }
}

fun register() {

    ToDoUtils.showTodo()
}

fun login() {

    println("\nAccount Ledger Authentication")
    print("Enter Your Username : ")
//    val username = readLine()
    val username = "banee_ishaque_k_10_04_2019"
    print("Enter Your Password : ")
//    val password = readLine()
    val password = "9895204814"

    val user = UserDataSource()
    println("Contacting Server...")
    val apiResponse: ResponseHolder<LoginResponse>
    runBlocking {

        apiResponse = user.selectUser(username = username, password = password)
    }
//    println("Response : $apiResponse")
    if (apiResponse.isError()) {

        println("Error : ${(apiResponse.getValue() as Exception).localizedMessage}")

    } else {

        val loginResponseResult = apiResponse.getValue() as LoginResponse
        when (loginResponseResult.userCount) {
            0 -> {

                println("Invalid Credentials...")

            }
            1 -> {

                println("Login Success...")
                userScreen(username, loginResponseResult.id)

            }
            else -> {

                println("Server Execution Error...")
            }
        }
    }
}

fun userScreen(username: String?, userId: Int) {

    do {
        PrintUtils.printMenu(listOf("\nUser : $username",
                "1 - List Accounts : Top Levels",
                "2 - Insert Quick Transaction",
                "3 - List Accounts : Full Names",
                "0 - Back",
                "",
                "Enter Your Choice : "))
        val choice = reader.nextInt()
        when (choice) {

            1 -> listAccountsTop(username, userId)
            2 -> insertQT()
            3 -> listAccountsFull()
            0 -> return
            else -> println("Invalid option, try again...")
        }
    } while (choice != 0)
}

fun listAccountsFull() {

    ToDoUtils.showTodo()
}

fun insertQT() {

    ToDoUtils.showTodo()
}

fun listAccountsTop(username: String?, userId: Int) {

    val apiResponse: ResponseHolder<AccountsResponse>
    val userAccountsDataSource = AccountsDataSource()
    println("Contacting Server...")
    runBlocking {

        apiResponse = userAccountsDataSource.selectUserAccounts(userId = userId)
    }
//    println("Response : $apiResponse")
    if (apiResponse.isError()) {

        println("Error : ${(apiResponse.getValue() as Exception).localizedMessage}")

    } else {

        val accountsResponseResult = apiResponse.getValue() as AccountsResponse
        if (accountsResponseResult.status == 1) {

            println("No Entries...")

        } else {

//            val userAccountsMap = HashMap<Int, AccountResponse>()
//            accountsResponseResult.accounts.forEach {
//
//                account ->
//                userAccountsMap[account.id] = account
//            }
            do {
                PrintUtils.printMenu(listOf("\nUser : $username",
                        "Accounts",
                        userAccountsToString(accountsResponseResult.accounts),
                        "1 - Choose Account - By Index Number",
                        "2 - Add Account",
                        "0 - Back",
                        "",
                        "Enter Your Choice : "))
                val choice = reader.nextInt()
                when (choice) {

                    1 -> chooseAccountByIndex()
                    2 -> addAccount()
                    0 -> return
                    else -> println("Invalid option, try again...")
                }
            } while (choice != 0)
        }
    }
}

fun userAccountsToString(accounts: List<AccountResponse>): String {

    var result=""
    accounts.forEach{
        account ->
        result += "A${account.id} - ${account.name}\n"
    }
    return result
}

fun addAccount() {

    ToDoUtils.showTodo()
}

fun chooseAccountByIndex() {

    ToDoUtils.showTodo()
}

